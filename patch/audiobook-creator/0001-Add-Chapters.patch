From c3f797f94fa28efef596ae0c4d350dba4d44677f Mon Sep 17 00:00:00 2001
From: Raghav <ragha.nv@gmail.com>
Date: Sat, 11 Oct 2025 16:27:17 -0700
Subject: [PATCH] Add chapters

---
 app.py                   |   4 +-
 generate_audiobook.py    |  37 ++++++--
 requirements_gpu.txt     |   2 +-
 utils/audiobook_utils.py | 188 +++++++++++++++++++++++++++++++--------
 4 files changed, 181 insertions(+), 50 deletions(-)

diff --git a/app.py b/app.py
index 8035285..7370896 100644
--- a/app.py
+++ b/app.py
@@ -345,7 +345,7 @@ with gr.Blocks(css=css, theme=gr.themes.Default()) as gradio_app:
                 output_format = gr.Dropdown(
                     ["M4B (Chapters & Cover)", "AAC", "M4A", "MP3", "WAV", "OPUS", "FLAC", "PCM"], 
                     label="Output Format",
-                    value="M4B (Chapters & Cover)",
+                    value="M4A",
                     info="M4B supports chapters and cover art"
                 )
             
@@ -465,4 +465,4 @@ app = gr.mount_gradio_app(app, gradio_app, path="/")  # Mount Gradio at root
 
 if __name__ == "__main__":
     import uvicorn
-    uvicorn.run(app, host="0.0.0.0", port=7860)
\ No newline at end of file
+    uvicorn.run(app, host="0.0.0.0", port=7860)
diff --git a/generate_audiobook.py b/generate_audiobook.py
index 1711db2..e16165e 100755
--- a/generate_audiobook.py
+++ b/generate_audiobook.py
@@ -16,6 +16,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 """
 
+import unicodedata
 import shutil
 from openai import OpenAI, AsyncOpenAI
 from tqdm import tqdm
@@ -56,10 +57,16 @@ def sanitize_filename(text):
     text = text.replace("'", '').replace('"', '').replace('/', ' ').replace('.', ' ')
     text = text.replace(':', '').replace('?', '').replace('\\', '').replace('|', '')
     text = text.replace('*', '').replace('<', '').replace('>', '').replace('&', 'and')
-    
-    # Normalize whitespace and trim
-    text = ' '.join(text.split())
-    
+    text = text.replace('!', '').replace('@', '').replace('#', '').replace('$', '').replace('%', '')
+    text = text.replace('^', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
+    text = text.replace('{', '').replace('}', '').replace('+', '').replace('=', '')
+    text = text.replace(',', '_').replace(' ', '_')
+
+    # Normalize non-ASCII to closest ASCII equivalent
+    text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('ascii')
+
+    # Collapse multiple underscores
+    text = re.sub(r'_+', '_', text).strip('_')
     return text
 
 def is_only_punctuation(text):
@@ -381,13 +388,18 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     
     # Process tasks with progress updates
     last_reported = -1
+    latest_chapter_name = None
     while tasks:
         done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
         
         # Store results as tasks complete
         for completed_task in done:
             idx = task_to_index[completed_task]
-            results_all[idx] = completed_task.result()
+            result = completed_task.result()
+            results_all[idx] = result
+
+            if result and result["is_chapter_heading"]:
+                latest_chapter_name = result['line']
         
         tasks = list(pending)
         
@@ -395,7 +407,7 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
         if progress_counter > last_reported:
             last_reported = progress_counter
             percent = (progress_counter / total_size) * 100
-            yield f"Generating audiobook. Progress: {percent:.1f}%"
+            yield f"Generating audiobook. Chapter: {latest_chapter_name or 'N/A'}. Progress: {percent:.1f}%"
     
     # All tasks have completed at this point and results_all is populated
     results = [r for r in results_all if r is not None]  # Filter out empty lines
@@ -410,6 +422,7 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     # Second pass: Organize by chapters
     chapter_organization_bar = tqdm(total=len(results), unit="result", desc="Organizing Chapters")
     
+    chapter_line_text_map = {}
     for result in sorted(results, key=lambda x: x["index"]):
         # Check if this is a chapter heading
         if result["is_chapter_heading"]:
@@ -422,6 +435,7 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
             
         # Add this line index to the chapter
         chapter_line_map[current_chapter_audio].append(result["index"])
+        chapter_line_text_map[result["index"]] = result["line"]
         chapter_organization_bar.update(1)
     
     chapter_organization_bar.close()
@@ -430,13 +444,18 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     # Third pass: Concatenate audio files for each chapter in order
     chapter_assembly_bar = tqdm(total=len(chapter_files), unit="chapter", desc="Assembling Chapters")
     
+    SILENCE_DURATION_MS = 1000
+    line_timings = []
     for chapter_file in chapter_files:
         # Use FFmpeg-based assembly instead of PyDub for memory efficiency
         assemble_chapter_with_ffmpeg(
             chapter_file, 
             chapter_line_map[chapter_file], 
             temp_line_audio_dir, 
-            temp_audio_dir
+            temp_audio_dir,
+            chapter_line_text_map,
+            line_timings,
+            SILENCE_DURATION_MS
         )
         
         chapter_assembly_bar.update(1)
@@ -453,7 +472,7 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
         chapter_path = os.path.join(temp_audio_dir, chapter_file)
         
         # Use FFmpeg-based silence addition instead of PyDub for memory efficiency
-        add_silence_to_chapter_with_ffmpeg(chapter_path, 1000)  # 1 second silence
+        add_silence_to_chapter_with_ffmpeg(chapter_path, SILENCE_DURATION_MS)  # 1 second silence
         
         post_processing_bar.update(1)
         yield f"Added silence to chapter: {chapter_file}"
@@ -483,7 +502,7 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     else:
         # Merge all chapter files into a standard M4A audiobook
         yield "Creating final audiobook..."
-        merge_chapters_to_standard_audio_file(m4a_chapter_files)
+        merge_chapters_to_standard_audio_file(m4a_chapter_files, line_timings)
         convert_audio_file_formats("m4a", output_format, "generated_audiobooks", "audiobook")
         yield f"Audiobook in {output_format} format created successfully"
 
diff --git a/requirements_gpu.txt b/requirements_gpu.txt
index 32e95bf..1db477c 100644
--- a/requirements_gpu.txt
+++ b/requirements_gpu.txt
@@ -83,7 +83,7 @@ semantic-version==2.10.0
 sentencepiece==0.2.0
 setuptools==76.0.0
 shellingham==1.5.4
-six==1.12.0
+six==1.17.0
 sniffio==1.3.1
 sortedcontainers==2.4.0
 soupsieve==2.6
diff --git a/utils/audiobook_utils.py b/utils/audiobook_utils.py
index df8ac0b..5c935e2 100644
--- a/utils/audiobook_utils.py
+++ b/utils/audiobook_utils.py
@@ -16,6 +16,8 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 """
 
+import tempfile
+import shutil
 import subprocess
 import re
 import os
@@ -655,53 +657,150 @@ def add_silence_to_audio_file_by_reencoding_using_ffmpeg(temp_dir, input_file_na
     except OSError as e:
         raise RuntimeError(f"Failed to rename file: {e}")
 
-def merge_chapters_to_standard_audio_file(chapter_files):
+def generate_line_timings_json(line_timings):
     """
-    Uses ffmpeg to merge all chapter files into a standard M4A audio file).
+    Convert line timing data to a compact JSON string suitable for embedding
+    in FFmpeg metadata (comment field).
 
-    This function takes a list of chapter files and an output format as input, and generates a standard M4A audio file.
+    Escapes special characters per FFMETADATA spec:
+        '=', ';', '#', '\\', and newline.
+    """
+    if not line_timings:
+        return None
+
+    def escape_ffmetadata_chars(text: str) -> str:
+        text = text.replace("\\", "\\\\")
+        text = text.replace("=", "\\=")
+        text = text.replace(";", "\\;")
+        text = text.replace("#", "\\#")
+        return text
+
+    line_data = [
+        {
+            "startTime": round(line["start"], 3),
+            "endTime": round(line["end"], 3),
+            "text": line["text"]
+        }
+        for line in line_timings
+    ]
+
+    json_comment = json.dumps(line_data, ensure_ascii=False)
+    json_comment = escape_ffmetadata_chars(json_comment)
+
+    return json_comment
+
+def merge_chapters_to_standard_audio_file(chapter_files, line_timings=None):
+    """
+    Merge chapter audio files into a standard M4A with jumpable chapters.
+    Converts WAV/PCM/AAC chapters to AAC/M4A before concatenation.
+    Uses original filenames (without extension) as chapter titles.
 
     Args:
-        chapter_files (list): A list of the paths to the individual chapter audio files.
+        chapter_files (list): A list of the names of individual chapter audio files (inside temp_audio).
     """
-    file_list_path = "chapter_list.txt"
-    
-    # Write the list of chapter files to a text file (ffmpeg input)
-    with open(file_list_path, "w", encoding='utf-8') as f:
-        for chapter in chapter_files:
-            chapter_path = os.path.join('temp_audio', chapter)
-            # Validate each chapter file
-            if not validate_file_path(chapter_path):
-                raise ValueError(f"Invalid chapter file: {chapter}")
-            f.write(f"file '{chapter_path}'\n")
+    if not chapter_files:
+        raise ValueError("No chapter files provided.")
 
-    # Construct the output file path
-    output_file = "generated_audiobooks/audiobook.m4a"
+    os.makedirs("generated_audiobooks", exist_ok=True)
 
-    # Validate file list exists
-    if not validate_file_path(file_list_path):
-        raise ValueError("Chapter list file is invalid")
+    # Temporary folder for converted M4A chapters
+    temp_dir = tempfile.mkdtemp(prefix="chapters_")
+    converted_files = []
 
-    # Construct secure ffmpeg command
-    ffmpeg_cmd = [
-        "ffmpeg", "-y", 
-        "-f", "concat", "-safe", "0", 
-        "-i", file_list_path, 
-        "-c", "copy", 
+    # 1. Convert all chapters to M4A (if needed)
+    for chapter in chapter_files:
+        input_path = os.path.join("temp_audio", chapter)
+        if not os.path.exists(input_path):
+            raise ValueError(f"Invalid chapter file: {chapter}")
+
+        output_path = os.path.join(temp_dir, os.path.splitext(chapter)[0] + ".m4a")
+
+        if chapter.lower().endswith(".wav"):
+            create_m4a_file_from_wav_file(input_path, output_path)
+        elif chapter.lower().endswith(".aac"):
+            create_m4a_file_from_raw_aac_file(input_path, output_path)
+        elif chapter.lower().endswith(".m4a"):
+            shutil.copy(input_path, output_path)
+        else:
+            raise ValueError(f"Unsupported chapter format: {chapter}")
+
+        converted_files.append(output_path)
+
+    # 2. Create concat list
+    concat_file = os.path.join(temp_dir, "chapter_list.txt")
+    with open(concat_file, "w", encoding="utf-8") as f:
+        for path in converted_files:
+            f.write(f"file '{path}'\n")
+
+    # 3. Merge into one M4A
+    temp_merged = os.path.join(temp_dir, "temp_merged.m4a")
+    subprocess.run([
+        "ffmpeg", "-y",
+        "-f", "concat", "-safe", "0",
+        "-i", concat_file,
+        "-c", "copy",
+        temp_merged
+    ], check=True)
+
+    # 4. Create chapter metadata
+    metadata_file = os.path.join("generated_audiobooks/", "metadata.txt")
+    with open(metadata_file, "w", encoding="utf-8") as f:
+        f.write(";FFMETADATA1\n")
+
+        json_comment = generate_line_timings_json(line_timings)
+        if json_comment:
+            print("Embedding line timing information as JSON in metadata comment")
+            f.write(f"comment={json_comment}\n\n")
+
+        start_time = 0
+        for chapter, path in zip(chapter_files, converted_files):
+            # Get duration in seconds
+            result = subprocess.run(
+                ["ffprobe", "-v", "error", "-show_entries",
+                 "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", path],
+                capture_output=True, text=True, check=True
+            )
+            duration = float(result.stdout.strip())
+            end_time = start_time + int(duration * 1000)
+
+            # Use original filename (without extension) as chapter title
+            chapter_title = os.path.splitext(os.path.basename(chapter))[0]
+            f.write(f"[CHAPTER]\nTIMEBASE=1/1000\nSTART={start_time}\nEND={end_time}\ntitle={chapter_title}\n")
+
+            start_time = end_time
+
+    # 5. Attach metadata
+    output_file = "generated_audiobooks/audiobook.m4a"
+    subprocess.run([
+        "ffmpeg", "-y",
+        "-i", temp_merged,
+        "-i", metadata_file,
+        "-map_metadata", "1",
+        "-c", "copy",
         output_file
-    ]
+    ], check=True)
+
+    # 6. Clean up
+    shutil.rmtree(temp_dir)
+
+    print(f"Audiobook created with chapters: {output_file}")
 
-    # Use centralized secure command execution
-    allowed_ffmpeg_commands = ['ffmpeg']
-    result = run_shell_command_secure(ffmpeg_cmd, allowed_ffmpeg_commands)
-    
-    if not result or result.returncode != 0:
-        error_msg = result.stderr if result else "Unknown error"
-        raise RuntimeError(f"FFmpeg failed: {error_msg}")
-        
-    print(f"Audiobook created: {output_file}")
 
-def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir, temp_audio_dir):
+def get_duration(path):
+    result = subprocess.run(
+            [
+                "ffprobe", "-v", "error",
+                "-show_entries", "format=duration",
+                "-of", "default=noprint_wrappers=1:nokey=1",
+                path
+            ],
+            capture_output=True,
+            text=True,
+            check=True
+        )
+    return float(result.stdout.strip())
+
+def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir, temp_audio_dir, line_text, timings = [], silence_duration_ms=0):
     """
     Memory-efficient chapter assembly using FFmpeg instead of PyDub.
     
@@ -719,7 +818,10 @@ def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir
     
     # Create a temporary file list for FFmpeg concat
     file_list_path = os.path.join(temp_audio_dir, f"chapter_list_{chapter_file}.txt")
-    
+    if timings:
+        current_time = timings[-1]['end']
+    else:
+        current_time = 0.0
     try:
         with open(file_list_path, "w", encoding='utf-8') as f:
             for line_index in sorted(line_indices):
@@ -727,7 +829,17 @@ def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir
                 # Use absolute path to avoid issues with FFmpeg concat
                 abs_line_path = os.path.abspath(line_path)
                 f.write(f"file '{abs_line_path}'\n")
-        
+                start_time = current_time
+                current_time =  start_time + get_duration(abs_line_path)
+                timings.append({
+                    "text": line_text[line_index],
+                    "start": start_time,
+                    "end": current_time
+                })
+
+            if line_indices:
+                timings[-1]['end'] += (silence_duration_ms / 1000.0)
+
         # Create the full chapter file path
         chapter_path = os.path.join(temp_audio_dir, chapter_file)
         
-- 
2.36.1.windows.1

