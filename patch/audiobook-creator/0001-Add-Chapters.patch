From e330b0abe50d04acc87150425f65dc00b0f66e21 Mon Sep 17 00:00:00 2001
From: Raghav <ragha.nv@gmail.com>
Date: Sat, 11 Oct 2025 16:27:17 -0700
Subject: [PATCH] Add chapters

---
 app.py                   |  45 +++-
 generate_audiobook.py    | 432 ++++++++++++++++++---------------------
 utils/audiobook_utils.py | 188 +++++++++++++----
 3 files changed, 391 insertions(+), 274 deletions(-)

diff --git a/app.py b/app.py
index 8035285..86b78e9 100644
--- a/app.py
+++ b/app.py
@@ -19,6 +19,7 @@ along with this program.  If not, see <https://www.gnu.org/licenses/>.
 import gradio as gr
 import os
 import traceback
+import json
 from fastapi import FastAPI
 from book_to_txt import process_book_and_extract_text, save_book
 from identify_characters_and_output_book_to_jsonl import process_book_and_identify_characters
@@ -44,6 +45,25 @@ def validate_book_upload(book_file, book_title):
     
     return gr.Info(f"Book '{book_title}' ready for processing.", duration=5)
 
+def validate_knowledge_base(kb_file):
+    """Validate knowledge base JSON file and return a notification"""
+    if kb_file is None:
+        return gr.Info("No knowledge base provided. Character identification will use default method.", duration=5)
+    
+    try:
+        with open(kb_file, 'r', encoding='utf-8') as f:
+            kb_data = json.load(f)
+        
+        # Basic validation - check if it's a valid JSON structure
+        if not isinstance(kb_data, (dict, list)):
+            return gr.Warning("Knowledge base must be a JSON object or array.")
+        
+        return gr.Info(f"Knowledge base loaded successfully! ({len(kb_data) if isinstance(kb_data, list) else len(kb_data.keys())} entries)", duration=5)
+    except json.JSONDecodeError as e:
+        return gr.Warning(f"Invalid JSON format in knowledge base: {str(e)}")
+    except Exception as e:
+        return gr.Warning(f"Error reading knowledge base: {str(e)}")
+
 def text_extraction_wrapper(book_file, text_decoding_option, book_title):
     """Wrapper for text extraction with validation and progress updates"""
     if book_file is None or not book_title:
@@ -141,7 +161,7 @@ async def add_emotion_tags_wrapper():
         yield None
         return
 
-async def generate_audiobook_wrapper(voice_type, narrator_gender, output_format, book_file, emotion_tags_processed_state):
+async def generate_audiobook_wrapper(voice_type, narrator_gender, output_format, book_file, emotion_tags_processed_state, kb_file):
     """Wrapper for audiobook generation with validation and progress updates"""
     if book_file is None:
         yield gr.Warning("Please upload a book file first."), None
@@ -176,7 +196,7 @@ async def generate_audiobook_wrapper(voice_type, narrator_gender, output_format,
         last_output = None
         audiobook_path = None
         # Pass through all yield values from the original function
-        async for output in process_audiobook_generation(voice_type, narrator_gender, output_format, book_file, add_emotion_tags):
+        async for output in process_audiobook_generation(voice_type, narrator_gender, output_format, book_file, add_emotion_tags, kb_file):
             last_output = output
             yield output, None  # Yield each progress update without file path
         
@@ -320,6 +340,15 @@ with gr.Blocks(css=css, theme=gr.themes.Default()) as gradio_app:
         with gr.Column():
             gr.Markdown('<div class="step-heading">🎧 Step 4: Generate Audiobook</div>')
             
+            # Knowledge base file input
+            kb_input = gr.File(
+                label="Knowledge Base (Optional)",
+                file_types=[".json", ".txt"],
+                info="Upload a JSON knowledge base file to enhance audiobook generation. This can contain character information, relationships, or other contextual data."
+            )
+            
+            validate_kb_btn = gr.Button("Validate Knowledge Base", variant="secondary", size="sm")
+            
             with gr.Row():
                 voice_type = gr.Radio(
                     ["Single Voice", "Multi-Voice"], 
@@ -345,7 +374,7 @@ with gr.Blocks(css=css, theme=gr.themes.Default()) as gradio_app:
                 output_format = gr.Dropdown(
                     ["M4B (Chapters & Cover)", "AAC", "M4A", "MP3", "WAV", "OPUS", "FLAC", "PCM"], 
                     label="Output Format",
-                    value="M4B (Chapters & Cover)",
+                    value="M4A",
                     info="M4B supports chapters and cover art"
                 )
             
@@ -419,10 +448,16 @@ with gr.Blocks(css=css, theme=gr.themes.Default()) as gradio_app:
         outputs=[emotion_tags_status_display, emotion_tags_processed]
     )
     
+    validate_kb_btn.click(
+        validate_knowledge_base,
+        inputs=[kb_input],
+        outputs=[]
+    )
+    
     # Update the generate_audiobook_wrapper to output both progress text and file path
     generate_btn.click(
         generate_audiobook_wrapper, 
-        inputs=[voice_type, narrator_gender, output_format, book_input, emotion_tags_processed], 
+        inputs=[voice_type, narrator_gender, output_format, book_input, emotion_tags_processed, kb_input], 
         outputs=[audio_output, audiobook_file],
         queue=True
     ).then(
@@ -465,4 +500,4 @@ app = gr.mount_gradio_app(app, gradio_app, path="/")  # Mount Gradio at root
 
 if __name__ == "__main__":
     import uvicorn
-    uvicorn.run(app, host="0.0.0.0", port=7860)
\ No newline at end of file
+    uvicorn.run(app, host="0.0.0.0", port=7860)
diff --git a/generate_audiobook.py b/generate_audiobook.py
index 1711db2..7162cfe 100755
--- a/generate_audiobook.py
+++ b/generate_audiobook.py
@@ -16,6 +16,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 """
 
+import unicodedata
 import shutil
 from openai import OpenAI, AsyncOpenAI
 from tqdm import tqdm
@@ -56,10 +57,16 @@ def sanitize_filename(text):
     text = text.replace("'", '').replace('"', '').replace('/', ' ').replace('.', ' ')
     text = text.replace(':', '').replace('?', '').replace('\\', '').replace('|', '')
     text = text.replace('*', '').replace('<', '').replace('>', '').replace('&', 'and')
-    
-    # Normalize whitespace and trim
-    text = ' '.join(text.split())
-    
+    text = text.replace('!', '').replace('@', '').replace('#', '').replace('$', '').replace('%', '')
+    text = text.replace('^', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
+    text = text.replace('{', '').replace('}', '').replace('+', '').replace('=', '')
+    text = text.replace(',', '_').replace(' ', '_')
+
+    # Normalize non-ASCII to closest ASCII equivalent
+    text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('ascii')
+
+    # Collapse multiple underscores
+    text = re.sub(r'_+', '_', text).strip('_')
     return text
 
 def is_only_punctuation(text):
@@ -207,6 +214,151 @@ def validate_book_for_m4b_generation(book_path):
     except Exception as e:
         return False, f"Unexpected error during book validation: {str(e)}", None
 
+async def process_audio_results_and_generate_audiobook(
+    results_all,
+    task_to_index,
+    tasks,
+    progress_counter,
+    total_lines,
+    temp_line_audio_dir,
+    temp_audio_dir,
+    chapter_files,
+    output_format,
+    generate_m4b_audiobook_file,
+    book_path,
+    progress_bar
+):
+    """
+    Common function to process audio results and generate the final audiobook.
+    Extracted from both generate_audio_with_single_voice and generate_audio_with_multiple_voices.
+    """
+    # Initialize chapter tracking variables
+    chapter_index = 1
+    current_chapter_audio = "Introduction.wav"
+    chapter_line_map = {}
+    
+    # Process tasks with progress updates
+    last_reported = -1
+    latest_chapter_name = None
+    while tasks:
+        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
+        
+        # Store results as tasks complete
+        for completed_task in done:
+            idx = task_to_index[completed_task]
+            result = completed_task.result()
+            results_all[idx] = result
+
+            if result and result["is_chapter_heading"]:
+                latest_chapter_name = result['line']
+        
+        tasks = list(pending)
+        
+        # Only yield if the counter has changed
+        if progress_counter > last_reported:
+            last_reported = progress_counter
+            percent = (progress_counter / total_lines) * 100
+            yield f"Generating audiobook. Chapter: {latest_chapter_name or 'N/A'}. Progress: {percent:.1f}%"
+    
+    # All tasks have completed at this point and results_all is populated
+    results = [r for r in results_all if r is not None]  # Filter out empty lines
+    
+    progress_bar.close()
+    
+    # Filter out empty lines (same as in your original code)
+    results = [r for r in results_all if r is not None]
+    
+    yield "Completed generating audio for all lines"
+
+    # Second pass: Organize by chapters
+    chapter_organization_bar = tqdm(total=len(results), unit="result", desc="Organizing Chapters")
+    yield "Organizing lines into chapters"
+    
+    chapter_line_text_map = {}
+    for result in sorted(results, key=lambda x: x["index"]):
+        # Check if this is a chapter heading
+        if result["is_chapter_heading"]:
+            chapter_index += 1
+            current_chapter_audio = f"{sanitize_filename(result['line'])}.wav"
+            
+        if current_chapter_audio not in chapter_files:
+            chapter_files.append(current_chapter_audio)
+            chapter_line_map[current_chapter_audio] = []
+            
+        # Add this line index to the chapter
+        chapter_line_map[current_chapter_audio].append(result["index"])
+        chapter_line_text_map[result["index"]] = result["line"]
+        chapter_organization_bar.update(1)
+    
+    chapter_organization_bar.close()
+    yield f"Organized {len(results)} lines into {len(chapter_files)} chapters"
+    
+    # Third pass: Concatenate audio files for each chapter in order
+    chapter_assembly_bar = tqdm(total=len(chapter_files), unit="chapter", desc="Assembling Chapters")
+    
+    SILENCE_DURATION_MS = 1000
+    line_timings = []
+    for chapter_file in chapter_files:
+        # Use FFmpeg-based assembly instead of PyDub for memory efficiency
+        assemble_chapter_with_ffmpeg(
+            chapter_file, 
+            chapter_line_map[chapter_file], 
+            temp_line_audio_dir, 
+            temp_audio_dir,
+            chapter_line_text_map,
+            line_timings,
+            SILENCE_DURATION_MS
+        )
+        
+        chapter_assembly_bar.update(1)
+        yield f"Assembled chapter: {chapter_file}"
+    
+    chapter_assembly_bar.close()
+    yield "Completed assembling all chapters"
+    
+    # Post-processing steps
+    post_processing_bar = tqdm(total=len(chapter_files)*2, unit="task", desc="Post Processing")
+    
+    # Add silence to each chapter file using FFmpeg
+    for chapter_file in chapter_files:
+        chapter_path = os.path.join(temp_audio_dir, chapter_file)
+        
+        # Use FFmpeg-based silence addition instead of PyDub for memory efficiency
+        add_silence_to_chapter_with_ffmpeg(chapter_path, SILENCE_DURATION_MS)  # 1 second silence
+        
+        post_processing_bar.update(1)
+        yield f"Added silence to chapter: {chapter_file}"
+
+    m4a_chapter_files = []
+
+    # Convert all chapter files to M4A format
+    for chapter_file in chapter_files:
+        chapter_name = chapter_file.split('.')[0]
+        m4a_chapter_files.append(f"{chapter_name}.m4a")
+        # Convert WAV to M4A for better compatibility with timestamps and metadata
+        convert_audio_file_formats("wav", "m4a", temp_audio_dir, chapter_name)
+        post_processing_bar.update(1)
+        yield f"Converted chapter to M4A: {chapter_name}"
+    
+    post_processing_bar.close()
+    
+    # Clean up temp line audio files
+    yield "Cleaning up temporary files"
+    shutil.rmtree(temp_line_audio_dir)
+    yield "Temporary files cleanup complete"
+
+    if generate_m4b_audiobook_file:
+        # Merge all chapter files into a final m4b audiobook
+        yield "Creating M4B audiobook file..."
+        merge_chapters_to_m4b(book_path, m4a_chapter_files)
+        yield "M4B audiobook created successfully"
+    else:
+        # Merge all chapter files into a standard M4A audiobook
+        yield "Creating final audiobook..."
+        merge_chapters_to_standard_audio_file(m4a_chapter_files, line_timings)
+        convert_audio_file_formats("m4a", output_format, "generated_audiobooks", "audiobook")
+        yield f"Audiobook in {output_format} format created successfully"
+
 async def generate_audio_with_single_voice(output_format, narrator_gender, generate_m4b_audiobook_file=False, book_path="", add_emotion_tags=False):
     # Read the text from the file
     """
@@ -277,8 +429,6 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     semaphore = asyncio.Semaphore(TTS_MAX_PARALLEL_REQUESTS_BATCH_SIZE)
     
     # Initial setup for chapters
-    chapter_index = 1
-    current_chapter_audio = f"Introduction.wav"
     chapter_files = []
     
     # First pass: Generate audio for each line independently
@@ -289,9 +439,6 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     # For tracking progress with tqdm in an async context
     progress_bar = tqdm(total=total_size, unit="line", desc="Audio Generation Progress")
     
-    # Maps chapters to their line indices
-    chapter_line_map = {}
-    
     async def process_single_line(line_index, line):
         async with semaphore:
             nonlocal progress_counter
@@ -379,113 +526,22 @@ async def generate_audio_with_single_voice(output_format, narrator_gender, gener
     # Initialize results_all list
     results_all = [None] * len(lines)
     
-    # Process tasks with progress updates
-    last_reported = -1
-    while tasks:
-        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
-        
-        # Store results as tasks complete
-        for completed_task in done:
-            idx = task_to_index[completed_task]
-            results_all[idx] = completed_task.result()
-        
-        tasks = list(pending)
-        
-        # Only yield if the counter has changed
-        if progress_counter > last_reported:
-            last_reported = progress_counter
-            percent = (progress_counter / total_size) * 100
-            yield f"Generating audiobook. Progress: {percent:.1f}%"
-    
-    # All tasks have completed at this point and results_all is populated
-    results = [r for r in results_all if r is not None]  # Filter out empty lines
-    
-    progress_bar.close()
-    
-    # Filter out empty lines (same as in your original code)
-    results = [r for r in results_all if r is not None]
-    
-    yield "Completed generating audio for all lines"
-
-    # Second pass: Organize by chapters
-    chapter_organization_bar = tqdm(total=len(results), unit="result", desc="Organizing Chapters")
-    
-    for result in sorted(results, key=lambda x: x["index"]):
-        # Check if this is a chapter heading
-        if result["is_chapter_heading"]:
-            chapter_index += 1
-            current_chapter_audio = f"{sanitize_filename(result['line'])}.wav"
-            
-        if current_chapter_audio not in chapter_files:
-            chapter_files.append(current_chapter_audio)
-            chapter_line_map[current_chapter_audio] = []
-            
-        # Add this line index to the chapter
-        chapter_line_map[current_chapter_audio].append(result["index"])
-        chapter_organization_bar.update(1)
-    
-    chapter_organization_bar.close()
-    yield "Organizing audio by chapters complete"
-    
-    # Third pass: Concatenate audio files for each chapter in order
-    chapter_assembly_bar = tqdm(total=len(chapter_files), unit="chapter", desc="Assembling Chapters")
-    
-    for chapter_file in chapter_files:
-        # Use FFmpeg-based assembly instead of PyDub for memory efficiency
-        assemble_chapter_with_ffmpeg(
-            chapter_file, 
-            chapter_line_map[chapter_file], 
-            temp_line_audio_dir, 
-            temp_audio_dir
-        )
-        
-        chapter_assembly_bar.update(1)
-        yield f"Assembled chapter: {chapter_file}"
-    
-    chapter_assembly_bar.close()
-    yield "Completed assembling all chapters"
-    
-    # Post-processing steps
-    post_processing_bar = tqdm(total=len(chapter_files)*2, unit="task", desc="Post Processing")
-    
-    # Add silence to each chapter file using FFmpeg
-    for chapter_file in chapter_files:
-        chapter_path = os.path.join(temp_audio_dir, chapter_file)
-        
-        # Use FFmpeg-based silence addition instead of PyDub for memory efficiency
-        add_silence_to_chapter_with_ffmpeg(chapter_path, 1000)  # 1 second silence
-        
-        post_processing_bar.update(1)
-        yield f"Added silence to chapter: {chapter_file}"
-
-    m4a_chapter_files = []
-
-    # Convert all chapter files to M4A format
-    for chapter_file in chapter_files:
-        chapter_name = chapter_file.split('.')[0]
-        m4a_chapter_files.append(f"{chapter_name}.m4a")
-        # Convert WAV to M4A for better compatibility with timestamps and metadata
-        convert_audio_file_formats("wav", "m4a", temp_audio_dir, chapter_name)
-        post_processing_bar.update(1)
-        yield f"Converted chapter to M4A: {chapter_name}"
-    
-    post_processing_bar.close()
-    
-    # Clean up temp line audio files
-    shutil.rmtree(temp_line_audio_dir)
-    yield "Cleaned up temporary files"
-
-    if generate_m4b_audiobook_file:
-        # Merge all chapter files into a final m4b audiobook
-        yield "Creating M4B audiobook file..."
-        merge_chapters_to_m4b(book_path, m4a_chapter_files)
-        yield "M4B audiobook created successfully"
-    else:
-        # Merge all chapter files into a standard M4A audiobook
-        yield "Creating final audiobook..."
-        merge_chapters_to_standard_audio_file(m4a_chapter_files)
-        convert_audio_file_formats("m4a", output_format, "generated_audiobooks", "audiobook")
-        yield f"Audiobook in {output_format} format created successfully"
+    # Call common processing function
+    async for progress_msg in process_audio_results_and_generate_audiobook(
+        results_all,
+        task_to_index,
+        tasks,
+        progress_counter,
+        total_size,
+        temp_line_audio_dir,
+        temp_audio_dir,
+        chapter_files,
+        output_format,
+        generate_m4b_audiobook_file,
+        book_path,
+        progress_bar
+    ):
+        yield progress_msg
 
 def apply_emotion_tags_to_multi_voice_data(json_data_array):
     """
@@ -625,14 +681,10 @@ async def generate_audio_with_multiple_voices(output_format, narrator_gender, ge
     semaphore = asyncio.Semaphore(TTS_MAX_PARALLEL_REQUESTS_BATCH_SIZE)
     
     # Initial setup for chapters
-    chapter_index = 1
-    current_chapter_audio = f"Introduction.wav"
     chapter_files = []
     
     # First pass: Generate audio for each line independently
     # and track chapter organization
-    chapter_line_map = {}  # Maps chapters to their line indices
-
     progress_counter = 0
     
     # For tracking progress with tqdm in an async context
@@ -733,122 +785,40 @@ async def generate_audio_with_multiple_voices(output_format, narrator_gender, ge
     # Initialize results_all list
     results_all = [None] * len(json_data_array)
     
-    # Process tasks with progress updates
-    last_reported = -1
-    while tasks:
-        done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
-        
-        # Store results as tasks complete
-        for completed_task in done:
-            idx = task_to_index[completed_task]
-            results_all[idx] = completed_task.result()
-        
-        tasks = list(pending)
-        
-        # Only yield if the counter has changed
-        if progress_counter > last_reported:
-            last_reported = progress_counter
-            percent = (progress_counter / total_lines) * 100
-            yield f"Generating audiobook. Progress: {percent:.1f}%"
-    
-    # All tasks have completed at this point and results_all is populated
-    results = [r for r in results_all if r is not None]  # Filter out empty lines
-    
-    progress_bar.close()
-    
-    # Filter out empty lines (same as in your original code)
-    results = [r for r in results_all if r is not None]
-    
-    yield "Completed generating audio for all lines"
-    
-    # Second pass: Organize by chapters
-    chapter_organization_bar = tqdm(total=len(results), unit="result", desc="Organizing Chapters")
-    yield "Organizing lines into chapters"
-    
-    for result in sorted(results, key=lambda x: x["index"]):
-        # Check if this is a chapter heading
-        if result["is_chapter_heading"]:
-            chapter_index += 1
-            current_chapter_audio = f"{sanitize_filename(result['line'])}.wav"
-            
-        if current_chapter_audio not in chapter_files:
-            chapter_files.append(current_chapter_audio)
-            chapter_line_map[current_chapter_audio] = []
-            
-        # Add this line index to the chapter
-        chapter_line_map[current_chapter_audio].append(result["index"])
-        chapter_organization_bar.update(1)
-    
-    chapter_organization_bar.close()
-    yield f"Organized {len(results)} lines into {len(chapter_files)} chapters"
-    
-    # Third pass: Concatenate audio files for each chapter in order
-    chapter_assembly_bar = tqdm(total=len(chapter_files), unit="chapter", desc="Assembling Chapters")
-    
-    for chapter_file in chapter_files:
-        # Use FFmpeg-based assembly instead of PyDub for memory efficiency
-        assemble_chapter_with_ffmpeg(
-            chapter_file, 
-            chapter_line_map[chapter_file], 
-            temp_line_audio_dir, 
-            temp_audio_dir
-        )
-        
-        chapter_assembly_bar.update(1)
-        yield f"Assembled chapter: {chapter_file}"
-    
-    chapter_assembly_bar.close()
-    yield "Completed assembling all chapters"
-    
-    # Post-processing steps
-    post_processing_bar = tqdm(total=len(chapter_files)*2, unit="task", desc="Post Processing")
-    
-    # Add silence to each chapter file using FFmpeg
-    for chapter_file in chapter_files:
-        chapter_path = os.path.join(temp_audio_dir, chapter_file)
-        
-        # Use FFmpeg-based silence addition instead of PyDub for memory efficiency
-        add_silence_to_chapter_with_ffmpeg(chapter_path, 1000)  # 1 second silence
-        
-        post_processing_bar.update(1)
-        yield f"Added silence to chapter: {chapter_file}"
-
-    m4a_chapter_files = []
-
-    # Convert all chapter files to M4A format
-    for chapter_file in chapter_files:
-        chapter_name = chapter_file.split('.')[0]
-        m4a_chapter_files.append(f"{chapter_name}.m4a")
-        # Convert WAV to M4A for better compatibility with timestamps and metadata
-        convert_audio_file_formats("wav", "m4a", temp_audio_dir, chapter_name)
-        post_processing_bar.update(1)
-        yield f"Converted chapter to M4A: {chapter_name}"
-    
-    post_processing_bar.close()
-    
-    # Clean up temp line audio files
-    yield "Cleaning up temporary files"
-    shutil.rmtree(temp_line_audio_dir)
-    yield "Temporary files cleanup complete"
-
-    if generate_m4b_audiobook_file:
-        # Merge all chapter files into a final m4b audiobook
-        yield "Creating M4B audiobook file..."
-        merge_chapters_to_m4b(book_path, m4a_chapter_files)
-        yield "M4B audiobook created successfully"
-    else:
-        # Merge all chapter files into a standard M4A audiobook
-        yield "Creating final audiobook..."
-        merge_chapters_to_standard_audio_file(m4a_chapter_files)
-        convert_audio_file_formats("m4a", output_format, "generated_audiobooks", "audiobook")
-        yield f"Audiobook in {output_format} format created successfully"
-
-async def process_audiobook_generation(voice_option, narrator_gender, output_format, book_path, add_emotion_tags=False):
+    # Call common processing function
+    async for progress_msg in process_audio_results_and_generate_audiobook(
+        results_all,
+        task_to_index,
+        tasks,
+        progress_counter,
+        total_lines,
+        temp_line_audio_dir,
+        temp_audio_dir,
+        chapter_files,
+        output_format,
+        generate_m4b_audiobook_file,
+        book_path,
+        progress_bar
+    ):
+        yield progress_msg
+
+async def process_audiobook_generation(voice_option, narrator_gender, output_format, book_path, add_emotion_tags=False, kb_file=None):
     is_audio_generator_api_up, message = await check_if_audio_generator_api_is_up(async_openai_client)
 
     if not is_audio_generator_api_up:
         raise Exception(message)
 
+    # Load knowledge base if provided
+    kb_data = None
+    if kb_file:
+        try:
+            import json
+            with open(kb_file, 'r', encoding='utf-8') as f:
+                kb_data = json.load(f)
+            yield f"📚 Knowledge base loaded with {len(kb_data) if isinstance(kb_data, list) else len(kb_data.keys())} entries"
+        except Exception as e:
+            yield f"⚠️ Warning: Could not load knowledge base: {str(e)}"
+
     generate_m4b_audiobook_file = False
 
     if output_format == "M4B (Chapters & Cover)":
diff --git a/utils/audiobook_utils.py b/utils/audiobook_utils.py
index df8ac0b..5c935e2 100644
--- a/utils/audiobook_utils.py
+++ b/utils/audiobook_utils.py
@@ -16,6 +16,8 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 """
 
+import tempfile
+import shutil
 import subprocess
 import re
 import os
@@ -655,53 +657,150 @@ def add_silence_to_audio_file_by_reencoding_using_ffmpeg(temp_dir, input_file_na
     except OSError as e:
         raise RuntimeError(f"Failed to rename file: {e}")
 
-def merge_chapters_to_standard_audio_file(chapter_files):
+def generate_line_timings_json(line_timings):
     """
-    Uses ffmpeg to merge all chapter files into a standard M4A audio file).
+    Convert line timing data to a compact JSON string suitable for embedding
+    in FFmpeg metadata (comment field).
 
-    This function takes a list of chapter files and an output format as input, and generates a standard M4A audio file.
+    Escapes special characters per FFMETADATA spec:
+        '=', ';', '#', '\\', and newline.
+    """
+    if not line_timings:
+        return None
+
+    def escape_ffmetadata_chars(text: str) -> str:
+        text = text.replace("\\", "\\\\")
+        text = text.replace("=", "\\=")
+        text = text.replace(";", "\\;")
+        text = text.replace("#", "\\#")
+        return text
+
+    line_data = [
+        {
+            "startTime": round(line["start"], 3),
+            "endTime": round(line["end"], 3),
+            "text": line["text"]
+        }
+        for line in line_timings
+    ]
+
+    json_comment = json.dumps(line_data, ensure_ascii=False)
+    json_comment = escape_ffmetadata_chars(json_comment)
+
+    return json_comment
+
+def merge_chapters_to_standard_audio_file(chapter_files, line_timings=None):
+    """
+    Merge chapter audio files into a standard M4A with jumpable chapters.
+    Converts WAV/PCM/AAC chapters to AAC/M4A before concatenation.
+    Uses original filenames (without extension) as chapter titles.
 
     Args:
-        chapter_files (list): A list of the paths to the individual chapter audio files.
+        chapter_files (list): A list of the names of individual chapter audio files (inside temp_audio).
     """
-    file_list_path = "chapter_list.txt"
-    
-    # Write the list of chapter files to a text file (ffmpeg input)
-    with open(file_list_path, "w", encoding='utf-8') as f:
-        for chapter in chapter_files:
-            chapter_path = os.path.join('temp_audio', chapter)
-            # Validate each chapter file
-            if not validate_file_path(chapter_path):
-                raise ValueError(f"Invalid chapter file: {chapter}")
-            f.write(f"file '{chapter_path}'\n")
+    if not chapter_files:
+        raise ValueError("No chapter files provided.")
 
-    # Construct the output file path
-    output_file = "generated_audiobooks/audiobook.m4a"
+    os.makedirs("generated_audiobooks", exist_ok=True)
 
-    # Validate file list exists
-    if not validate_file_path(file_list_path):
-        raise ValueError("Chapter list file is invalid")
+    # Temporary folder for converted M4A chapters
+    temp_dir = tempfile.mkdtemp(prefix="chapters_")
+    converted_files = []
 
-    # Construct secure ffmpeg command
-    ffmpeg_cmd = [
-        "ffmpeg", "-y", 
-        "-f", "concat", "-safe", "0", 
-        "-i", file_list_path, 
-        "-c", "copy", 
+    # 1. Convert all chapters to M4A (if needed)
+    for chapter in chapter_files:
+        input_path = os.path.join("temp_audio", chapter)
+        if not os.path.exists(input_path):
+            raise ValueError(f"Invalid chapter file: {chapter}")
+
+        output_path = os.path.join(temp_dir, os.path.splitext(chapter)[0] + ".m4a")
+
+        if chapter.lower().endswith(".wav"):
+            create_m4a_file_from_wav_file(input_path, output_path)
+        elif chapter.lower().endswith(".aac"):
+            create_m4a_file_from_raw_aac_file(input_path, output_path)
+        elif chapter.lower().endswith(".m4a"):
+            shutil.copy(input_path, output_path)
+        else:
+            raise ValueError(f"Unsupported chapter format: {chapter}")
+
+        converted_files.append(output_path)
+
+    # 2. Create concat list
+    concat_file = os.path.join(temp_dir, "chapter_list.txt")
+    with open(concat_file, "w", encoding="utf-8") as f:
+        for path in converted_files:
+            f.write(f"file '{path}'\n")
+
+    # 3. Merge into one M4A
+    temp_merged = os.path.join(temp_dir, "temp_merged.m4a")
+    subprocess.run([
+        "ffmpeg", "-y",
+        "-f", "concat", "-safe", "0",
+        "-i", concat_file,
+        "-c", "copy",
+        temp_merged
+    ], check=True)
+
+    # 4. Create chapter metadata
+    metadata_file = os.path.join("generated_audiobooks/", "metadata.txt")
+    with open(metadata_file, "w", encoding="utf-8") as f:
+        f.write(";FFMETADATA1\n")
+
+        json_comment = generate_line_timings_json(line_timings)
+        if json_comment:
+            print("Embedding line timing information as JSON in metadata comment")
+            f.write(f"comment={json_comment}\n\n")
+
+        start_time = 0
+        for chapter, path in zip(chapter_files, converted_files):
+            # Get duration in seconds
+            result = subprocess.run(
+                ["ffprobe", "-v", "error", "-show_entries",
+                 "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", path],
+                capture_output=True, text=True, check=True
+            )
+            duration = float(result.stdout.strip())
+            end_time = start_time + int(duration * 1000)
+
+            # Use original filename (without extension) as chapter title
+            chapter_title = os.path.splitext(os.path.basename(chapter))[0]
+            f.write(f"[CHAPTER]\nTIMEBASE=1/1000\nSTART={start_time}\nEND={end_time}\ntitle={chapter_title}\n")
+
+            start_time = end_time
+
+    # 5. Attach metadata
+    output_file = "generated_audiobooks/audiobook.m4a"
+    subprocess.run([
+        "ffmpeg", "-y",
+        "-i", temp_merged,
+        "-i", metadata_file,
+        "-map_metadata", "1",
+        "-c", "copy",
         output_file
-    ]
+    ], check=True)
+
+    # 6. Clean up
+    shutil.rmtree(temp_dir)
+
+    print(f"Audiobook created with chapters: {output_file}")
 
-    # Use centralized secure command execution
-    allowed_ffmpeg_commands = ['ffmpeg']
-    result = run_shell_command_secure(ffmpeg_cmd, allowed_ffmpeg_commands)
-    
-    if not result or result.returncode != 0:
-        error_msg = result.stderr if result else "Unknown error"
-        raise RuntimeError(f"FFmpeg failed: {error_msg}")
-        
-    print(f"Audiobook created: {output_file}")
 
-def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir, temp_audio_dir):
+def get_duration(path):
+    result = subprocess.run(
+            [
+                "ffprobe", "-v", "error",
+                "-show_entries", "format=duration",
+                "-of", "default=noprint_wrappers=1:nokey=1",
+                path
+            ],
+            capture_output=True,
+            text=True,
+            check=True
+        )
+    return float(result.stdout.strip())
+
+def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir, temp_audio_dir, line_text, timings = [], silence_duration_ms=0):
     """
     Memory-efficient chapter assembly using FFmpeg instead of PyDub.
     
@@ -719,7 +818,10 @@ def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir
     
     # Create a temporary file list for FFmpeg concat
     file_list_path = os.path.join(temp_audio_dir, f"chapter_list_{chapter_file}.txt")
-    
+    if timings:
+        current_time = timings[-1]['end']
+    else:
+        current_time = 0.0
     try:
         with open(file_list_path, "w", encoding='utf-8') as f:
             for line_index in sorted(line_indices):
@@ -727,7 +829,17 @@ def assemble_chapter_with_ffmpeg(chapter_file, line_indices, temp_line_audio_dir
                 # Use absolute path to avoid issues with FFmpeg concat
                 abs_line_path = os.path.abspath(line_path)
                 f.write(f"file '{abs_line_path}'\n")
-        
+                start_time = current_time
+                current_time =  start_time + get_duration(abs_line_path)
+                timings.append({
+                    "text": line_text[line_index],
+                    "start": start_time,
+                    "end": current_time
+                })
+
+            if line_indices:
+                timings[-1]['end'] += (silence_duration_ms / 1000.0)
+
         # Create the full chapter file path
         chapter_path = os.path.join(temp_audio_dir, chapter_file)
         
-- 
2.36.1.windows.1

